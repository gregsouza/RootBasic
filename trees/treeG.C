/// \file
/// \ingroup tutorial_tree
/// \notebook -nodraw
/// This example is a variant of hsimple.C but using a TTree instead
/// of a TNtuple. It shows:
///   - how to fill a Tree with a few simple variables.
///   - how to read this Tree
///   - how to browse and analyze the Tree via the TBrowser and TTreeViewer
/// This example can be run in many different ways:
///   1. Using the Cling interpreter
/// ~~~
/// .x tree1.C
/// ~~~
///   2. Using the automatic compiler interface
/// ~~~
/// .x tree1.C++
/// ~~~
///   3. 
/// ~~~
/// .L tree1.C  or .L tree1.C++
/// tree1()
/// ~~~
/// One can also run the write and read parts in two separate sessions.
/// For example following one of the sessions above, one can start the session:
/// ~~~
///   .L tree1.C
///   tree1r();
/// ~~~
/// \macro_code
///
/// \author Rene Brun

#include "TROOT.h"
#include "TFile.h"
#include "TTree.h"
#include "TBrowser.h"
#include "TH2.h"
#include "TRandom.h"

void tree1w()
{
   //create a Tree file tree1.root

   //create the file, the Tree and a few branches
   TFile f("tree1.root","recreate");
   TTree t1("t1","a simple Tree with simple variables");
   Float_t px, py, pz;
   Double_t random;
   Int_t ev;
   t1.Branch("px",&px,"px/F");
   t1.Branch("py",&py,"py/F");
   t1.Branch("pz",&pz,"pz/F");
   t1.Branch("random",&random,"random/D");
   t1.Branch("ev",&ev,"ev/I");

   //fill the tree
   for (Int_t i=0;i<10000;i++) {
     px = i+0.1;
     py = i+0.2;
     pz = i+0.3;
     random = gRandom->Rndm();
     ev = i;
     t1.Fill();
  }

  //save the Tree header. The file will be automatically closed
  //when going out of the function scope
  t1.Write();
}

void tree1r()
{
   //read the Tree generated by tree1w and fill two histograms

   //note that we use "new" to create the TFile and TTree objects !
   //because we want to keep these objects alive when we leave this function.
   TFile *f = new TFile("tree1.root");
   TTree *t1 = (TTree*)f->Get("t1");
   Float_t px, py, pz;
   Double_t random;
   Int_t ev;
   t1->SetBranchAddress("px",&px);
   t1->SetBranchAddress("py",&py);
   t1->SetBranchAddress("pz",&pz);
   t1->SetBranchAddress("random",&random);
   t1->SetBranchAddress("ev",&ev);

   
   Float_t *ptr;
   for(int i=0; i<100; i++){
     t1->GetEntry(i);

     if(!i)
       ptr = &px;
     
     std::cout << px << "\t"<< *ptr  <<"\n";
     
   }

}

void treeG() {
   tree1w();
   tree1r();
}
